[
  {
    "objectID": "appendix_d1.html",
    "href": "appendix_d1.html",
    "title": "Appendix A.1 Introduction",
    "section": "",
    "text": "Appendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_d1.html#d.1-introduction",
    "href": "appendix_d1.html#d.1-introduction",
    "title": "Appendix D.1 Introduction",
    "section": "D.1 Introduction",
    "text": "D.1 Introduction\n\nHow to install Python 3 and write your first program\nGo to https://www.spyder-ide.org and download and install the latest version of Spyder.\nOnce installed, launch the program.\n\n\n\n\n\n\nNote\n\n\n\nFigure omitted in this web version.\n\n\n\n\nExercise D.1\nType print(\"Hello world\") in the editor window and press the green play button.\nWhat output do you get? Also try print(\"2+2=\", 2+2).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nRemark. Python treats \"2+2\" as text to be printed, and 2+2 as something to be computed. A comma is used to separate different types of input to print.\n\n\n\n\nA first look at basic syntax for arithmetic in Python\nWe now consider how to do basic arithmetic in Python.\nExample D.2 Enter the following code into the Spyder editor.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen you press the green play button you get the output a+b=6.\nHere, a, b, and c are variables. Technically speaking, a variable is a space in the memory of the computer which can store one piece of information, such as a number.\nExample D.3 Enter the following code into the Spyder editor.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen you press the green play button you still get the output a+b=6.\nLine-by-line explanation of Example D.2:\n\nPython creates a variable a and assigns it the value 2.\nPython creates a variable b and assigns it the value 4.\nPython creates a variable c, computes a + b, and assigns this value to c.\nPython prints the value of c on the screen (together with the string \"a+b=\").\n\nThe above example illustrates several peculiarities of arithmetic in Python and how a code is run:\n\nThe code is executed line by line.\nExpressions such as a = b should be read from right to left. That is, a is assigned whatever value b has, but not vice versa.\nIf a variable gets assigned some value, it has no memory of how that happened. Changing a later does not affect the value stored in c.\n\n\n\nExercise D.4\nExplore the various ways to do arithmetic operations in Python by running the following commands for suitable values of a and b:\na + b, a * b, a - b, a - -b, a / b, a // b, a % b.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nBasic rules for variable names\nWe now turn to a discussion of the basic syntax in Python. First, the types of names you are allowed to give a variable.\nExample D.5 You can give variables much more interesting names than just a, b, x, or y. Here is an example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe make the following remarks:\n\nPython is case sensitive. This means that n and N are as different as n and m.\nBy tradition, the name of a variable should never start with an upper case letter.\nA variable cannot be given a numerical name such as 2 or 34. Numbers can be part of the name of a variable, as long as the name starts with a letter or an underscore _. Certain special symbols, such as $, #, and %, can never be used in the name of a variable.\nThe name of a variable cannot contain a space.\nYou should not give a variable a name that already means something different. For instance, do not give a variable the name print (however, Print is fine).\n\n\n\nIndentation, line breaks, and comments\nExample D.6 In Python, we need to be careful with how we place indentations. For instance, both of the following programs will crash:\na = 2\nb = 4\n    c = a + b\nprint(c)\na = 2\nb = 4\nc = a + b\n  print(c)\n\nPython is careful with indentation. If Python does not understand why we make some indentation, it will crash.\nLater in this chapter, we will see situations where indentations become a natural part of the code (for loops, while loops, if-else structures, and functions).\n\nExample D.7 In contrast to the situation with indentations, Python is much less sensitive with respect to whether or not we skip a line. The following code runs just fine:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPython does not care if you skip a line, or twenty.\nYou can place multiple commands on the same line, as long as they are separated by a semicolon ;.\nEverything you write on a line following a hashtag # is ignored by Python.\nYou can use “soft” parentheses ( and ) just as you would in a normal computation. You cannot replace them with [ ] or { }.\nIt is a good thing for a program to crash. It is a way for Python to let you know that the result would probably have been false because the code was written in a bad way.\n\n\n\nExercise D.8\nWill the following codes run? If not, why? If yes, what is the output?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(c)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(d)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(e)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(f)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.9\nConsider the following codes. Can you express mathematically what they compute?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nHint: You have already seen these objects on page 87.\n\n\nA first look at how to efficiently repeat commands in Python\nIn Exercise D.9 above, you were asked to consider a code where an operation was repeated multiple times. We now explain one way this can be done using a for loop.\nExample D.10 (For-loop) The following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of the for loop:\n\nfor n in range(0, 4) means the block below is repeated for each n between 0 and 3 (but not 4).\nThe indented lines are run by the loop. The loop first runs with n = 0, then n = 1, and so on until n = 3.\nAfter the loop ends, Python moves on to the first unindented line following it.\n\n\n\nExercise D.11\nWill these codes run? If so, what are their outputs?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.12\nRewrite the code in Exercise D.9 using for loops.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nSome words on datatypes in Python\nPython stores variables in different ways depending on whether they contain text, numbers, or lists. We say that Python uses different datatypes. For instance, Python will treat a number differently depending on whether or not it is an integer.\nExample D.13\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.14\n\nCheck the type of the variable defined by b = 3/2.\nCheck the type of the variable defined by c = 4/2.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn addition to integers and floating point numbers, we will encounter the following datatypes in this chapter:\n\nString: a variable containing text, e.g. a = \"Hej\".\nList: a variable containing a list of other variables, e.g. a = [2, 3/2, \"Hej\"].\nNumpy array: a special type of list that can only contain integers or floating point numbers (and has more advanced features).\n\n\n\nHow to store and manipulate sequences using Python lists\nOne way of storing sequences in Python is by using lists.\nExample D.16\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe code is more or less explained by the comments, but we note:\n\nUse square brackets [ ] to create a list and commas , to separate entries.\nWriting a[3] = 10 changes an entry in the list.\nlen, sum, max, and min work only if the list contains numbers.\nLists are easy to modify with append, pop, concatenation, and slicing."
  },
  {
    "objectID": "appendix_d2.html",
    "href": "appendix_d2.html",
    "title": "Appendix A.2 Sequences and Sums",
    "section": "",
    "text": "Appendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_d2.html#d.2-how-to-compute-and-visualize-sequences-and-sums",
    "href": "appendix_d2.html#d.2-how-to-compute-and-visualize-sequences-and-sums",
    "title": "Appendix D.2 Sequences and Sums",
    "section": "D.2 How to compute and visualize sequences and sums",
    "text": "D.2 How to compute and visualize sequences and sums\n\nSome ways to compute sequences in Python\nSuppose we want to compute many entries of the sequence \\[\\left(\\frac{1}{2^k}\\right)_{k=0}^\\infty = \\left(1, \\frac{1}{2}, \\frac{1}{4}, \\dots \\right).\\]\nExample D.17 (Computing sequences using a for-loop)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAnother way of computing lists is to use a list comprehension. It has the benefit of both computing and storing a sequence of numbers in a single line of code.\nExample D.18 (Computing sequences using a list)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.19\nRun and compare the output of the codes in the above examples.\n\n\nExercise D.20\nA difference between the right-most codes in Examples D.17 and D.18 is that in the first, we do not store the values of the sequence anywhere. Here are two suggestions for how to fix this:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplain what is going on in each code. What information is stored at the end of each program? Also, why do these not give any output? Can you fix this?\n\n\nSome ways to compute partial sums of infinite series\nOn the previous page, we discussed how to compute and store values of a sequence. Let us now consider how to compute the sum of the first, say, million terms of the infinite series \\[\\sum_{k=0}^{\\infty} \\frac{1}{2^k} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\cdots.\\]\nExample D.21 (Computing sums using a for-loop)\nThe following two codes both compute the sum \\(1 + 1/2 + 1/4 + 1/8\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample D.22 (Computing a sum using lists)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing this technique, we can compute the sum in just one line:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.23\n\nRun the codes from the examples on this page. Why do they not give any output? Fix this.\nModify the code so that you can compute the sum of the first million terms or so. What result do you get?\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nHow to visualize sequences and partial sums using for-loops\nExample D.24\nThe following code is perhaps the simplest way to visualize a sequence in Python. Here, we visualize the sequence \\((1/2^k)_{k=0}^9\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nmatplotlib.pyplot provides plotting commands.\nThe for loop plots a blue dot at \\((k, 1/2^k)\\) for each k.\nplt.show() displays the figure.\n\nNow modify the code so that we plot partial sums of the infinite series \\[\\sum_{k=0}^\\infty \\frac{1}{2^k}.\\]\nExample D.25\nThe following code computes and visualizes the partial sums.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.26\nRun this code, and verify by computing the first three partial sums by hand that the plot is correct. What happens when you increase range(0, 3) to, say, range(0, 100)?\n\n\nExercise D.27\nSeveral commands can be used to change how the above figure looks. Try inserting the following into the code anywhere after the import and before plt.plot. What happens?\n\nReplace \"bo\" by \"rx\".\nplt.xlim(-3, 15)\nplt.ylim(-5, 2)\nplt.xlabel(\"There was\")\nplt.ylabel(\"a graph\")\nplt.title(\"that had a title\")\nplt.xticks([-2, 0, 3, 4, 6.5, 10])\nplt.yticks([0, 1, 1.5])\nplt.grid(True)\nplt.figure(figsize=(4, 3))\nplt.savefig(\"myfigure.jpg\")\n\nRemark: Note that by choosing the extension .jpg, you tell Python to save your figure as a jpg file. Only a limited number of file formats are supported.\n\n\nVisualizing sequences and partial sums stored as lists\nExample D.28\nWe now use lists to create and plot the sequence \\((1/2^n)_{n=0}^9\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nn_values gives the x-axis values.\na stores the sequence values.\nplt.plot(n_values, a, \"bo\") plots the points.\n\nExample D.29\nWe now use lists to compute and plot partial sums of \\[\\sum_{k=0}^\\infty \\frac{1}{2^k}.\\]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe key line is the list comprehension: S = [sum(a[0:n + 1]) for n in indices]. Remember that a[0:n + 1] contains the entries a[0], a[1], ..., a[n].\n\n\nExercise D.30\nImplement the code in Example D.29. Verify that it gives the same output as Example D.25 when the range in the latter example is suitably adjusted.\n\n\nA slightly more advanced example: the Fibonacci sequence\nThe Fibonacci numbers are \\[1, 1, 2, 3, 5, 8, 13, \\dots\\] and satisfy \\(a_n = a_{n-1} + a_{n-2}\\) for \\(n \\ge 2\\) when we set \\(a_0 = 1\\) and \\(a_1 = 1\\).\nExample D.31\nThe following code can be used to compute Fibonacci numbers.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.32\nImplement the code from the above example. Use a reference (for example, a list of Fibonacci numbers) to verify that it gives the correct output.\n\n\nExercise D.33\nUse the method of the above examples to create a list containing a few partial sums of the infinite series \\(\\sum_{k=0}^\\infty 1/2^k\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nRemark D.34 (for-loops versus list comprehensions)\nPure for-loops are available in most programming languages, while list comprehensions are specific to Python. If you want to adapt to other languages, use list comprehensions sparingly.\n\n\nRemark D.35 (how to time a computation)\nYou can measure how long it takes for a program to run. Here is how:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.36\nConsider the code:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWhat does the code compute?\nDo the same as in (1), except by first creating a sequence a and then computing its sum using sum(a).\nUse the timing code above to compare which method is fastest.\n\n\n\nRemark D.37\nPython is useful but fairly slow. Built-in commands are usually implemented in faster languages (such as C++), so if speed is important, use built-in functions as much as possible."
  },
  {
    "objectID": "appendix_d5.html",
    "href": "appendix_d5.html",
    "title": "Appendix A.5 Number Representation",
    "section": "",
    "text": "Appendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_d5.html#d.5-how-numbers-are-represented-in-python",
    "href": "appendix_d5.html#d.5-how-numbers-are-represented-in-python",
    "title": "Appendix D.5 Number Representation",
    "section": "D.5 How numbers are represented in Python",
    "text": "D.5 How numbers are represented in Python\nWe end this appendix by examining how numbers are represented in Python and some peculiar consequences of this.\n\nExample D.62\nAt the start of Chapter 3, we considered the infinite series \\[\\sum_{k=0}^{\\infty} \\frac{1}{2^k} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\cdots.\\]\nLet \\(S_n\\) denote the \\(n\\)th partial sum. The point is that \\(2 - S_n = 1/2^n\\), so \\(S_n \\ne 2\\). But if we ask Python to compute, say, \\(S_{100}\\), it returns 2.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.63\nDoes Python really mean that \\(S_{100} = 2\\), or is there something else going on? One way to double check is to ask Python to compute \\(1 / (2 - S_{100})\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nHow integers are represented in Python\nIf we run\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPython stores the integer using a fixed number of bits (modern computers typically use 64 bits for integers).\n\n\n\n\n\n\nNote\n\n\n\nFigures omitted in this web version.\n\n\nExample D.65 (Decimal and binary notation)\nIn decimal: \\[4132 = 4\\cdot10^3 + 1\\cdot10^2 + 3\\cdot10^1 + 2\\cdot10^0.\\]\nIn binary: \\[1101_2 = 1\\cdot2^3 + 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0.\\]\nIf it is not clear whether a number is written in binary or decimal, we can use the notations \\((1101)_2\\) and \\((1101)_{10}\\).\nCounting in binary: \\((0)_2=0\\), \\((1)_2=1\\), \\((10)_2=2\\), \\((11)_2=3\\), \\((100)_2=4\\), \\((101)_2=5\\), \\((110)_2=6\\), \\((111)_2=7\\), \\((1000)_2=8\\), and so on.\n\n\nExercise D.66\nCheck that the above list is correct, and continue the list to 20.\n\n\nExercise D.68\n\nWhat is the largest integer you can represent as an 8-bit integer?\nModern computers use 64-bit integers, where 1 bit is used for the sign and 63 for the number itself. What is the largest integer you can represent using a 64-bit integer?\n\nRemark D.69 (Two’s complement)\nOur explanation above is correct for positive integers. For negative integers, a strategy called two’s complement is used. For an 8-bit integer, this allows representation of integers from -128 to 127.\n\n\nHow non-integers are represented in Python\nReal numbers that are not integers are stored using the datatype float. Because memory is finite, not all real numbers can be represented exactly.\nRemark D.70 (Sloppy description of 64-bit floating numbers)\nA 64-bit computer sets aside 64 bits to represent a real number of the form \\(\\epsilon \\cdot 10^\\alpha\\), where \\(\\epsilon\\) is (roughly) a 16-digit integer and the exponent \\(\\alpha\\) is roughly between -340 and +292.\nExample D.71\nUsing the sloppy description, the number \\(\\sqrt{2}\\) is stored roughly as \\[1.414213562373095 \\cdot 10^0.\\]\n\n\nExercise D.72\nAccording to the sloppy definition:\n\nHow far is it between the floating point representation of \\(\\sqrt{2}\\) and its closest floating point neighbor?\nHow far is it between \\(x=0\\) and the next floating point number?\n\n\n\nExercise D.73\nPut a = 325660000, b = 0.000032566 and use Python to compute 100*(a+b), 1000*(a+b), and 10000*(a+b). How are the results stored? Are there any round-off errors?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.74\nUse the sloppy description of float numbers to do the following:\n\nExplain how large N has to be for the computer to think that \\(1 + 2^{-N} = 1\\).\nHow large does N have to be for the computer to think that \\(2^{-N} = 0\\)?\n\n\n\nExample D.75 (Binary notation for non-integers)\nBinary notation for non-integers works like decimal notation. Compare: \\[643.57_{10} = 6\\cdot10^2 + 4\\cdot10^1 + 3\\cdot10^0 + 5\\cdot10^{-1} + 7\\cdot10^{-2}\\] and \\[101.01_2 = 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2}.\\]\n\n\nExercise D.76\nAs a small taste of binary arithmetic, figure out both the decimal and binary representations of:\n\n\\((101.01)_2 \\cdot 2^2\\)\n\\((101.01)_2 \\cdot 2^1\\)\n\\((101.01)_2 \\cdot 2^{-1}\\)\n\n\n\nRemark D.77 (Accurate description of 64-bit floating point numbers)\nA 64-bit floating point number is stored in the form \\[(1.\\epsilon)_2 \\cdot 2^\\alpha,\\] where \\(\\epsilon\\) is a string of 52 bits and the exponent \\(\\alpha\\) is an 11-bit integer. The remaining bit is used for the sign.\nWhen the exponent \\(\\alpha\\) is the smallest possible, \\((1.\\epsilon)_2\\) is replaced by \\((0.\\epsilon)_2\\) to offer additional accuracy close to the origin.\n\n\n\n\n\n\nNote\n\n\n\nFigures omitted in this web version.\n\n\n\n\nExample D.78\nHow do we store \\(1/10\\) as a floating point number? The binary expansion of \\(1/10\\) is \\[0.00011001100110011\\ldots_2\\] which is repeating. This means it cannot be stored exactly, so we must round.\n\n\nExercise D.79\nTranslate the accurate description of 64-bit floating point numbers to decimal notation to obtain the sloppy description above. Take into account the added accuracy close to the origin.\n\n\nExercise D.80 (Challenging)\nExplain which fractions can be represented without round-off error as 64-bit floating point numbers.\n\n\nRemark D.81 (The effect of round-off errors)\nWhen using Python to compute and visualize data, we must consider whether results are real or caused by round-off error. This is especially important for functions with large or small scales."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Appendix Conversion",
    "section": "",
    "text": "A.1 Introduction\nA.2 Sequences and Sums\nA.3 Control Statements\nA.4 Functions\nA.5 Number Representation\nA.6 Answers\nA.All Combined"
  },
  {
    "objectID": "index.html#appendix",
    "href": "index.html#appendix",
    "title": "Appendix Conversion",
    "section": "",
    "text": "A.1 Introduction\nA.2 Sequences and Sums\nA.3 Control Statements\nA.4 Functions\nA.5 Number Representation\nA.6 Answers\nA.All Combined"
  },
  {
    "objectID": "appendix_d4.html",
    "href": "appendix_d4.html",
    "title": "Appendix A.4 Functions",
    "section": "",
    "text": "Appendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_d4.html#d.4-functions-in-python",
    "href": "appendix_d4.html#d.4-functions-in-python",
    "title": "Appendix D.4 Functions",
    "section": "D.4 Functions in Python",
    "text": "D.4 Functions in Python\n\nHow to define a function in Python\nExample D.47 (Defining functions in Python)\nIn the following code we define \\(f(x) = x^2 - 5x + 4\\) in Python and compute \\(f(3)\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\ndef f(x): tells Python that a function named f is being defined.\nThe return value is the output of the function.\nWhen we write f(3), the function code is run with x = 3.\n\n\n\nExercise D.48\n\nUse the if-control statement to implement the absolute value function. Use it on a few values to check that it works.\nImplement the absolute value function without using the if-control statement.\n\nRemark: It is not really necessary to program the absolute value function by hand since it already exists in Python as abs(x).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.49\nWrite the code for a function that will take a list of numbers as input and return their product as output. This is analogous to the built-in function sum() which returns the sum.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nWarning: the importance of local namespaces\nVariables created inside a function are local and cannot be accessed outside the function. This is a common source of bugs.\nExample D.50\nThe following code makes no sense and will crash.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample D.51\nThe following code also crashes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe variable y only exists inside the function definition. After the function returns, local variables are deleted.\nExample D.52\nThanks to local namespaces, we can be sure that the following code works:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nHow to plot functions in Python using lists\nExample D.53 (Plotting with datatype list)\nThe following code plots \\(f(x) = x^2 + 2x + 3\\) over the interval \\([0, 1]\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe command plt.plot(X, Y) connects the points with straight line segments. If you use plt.plot(X, Y, \"bo\") you will get blue dots instead of a line.\n\n\nExercise D.54\nPlot the functions you implemented in Exercise D.48 on \\([1/2, 2]\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.55\nConsider the following code:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExplain in mathematical terms what this code does.\nThe symbol a takes more than one role in the above code. Explain what roles these are.\nMake the code easier to read by giving a different names where possible.\n\n\n\nPlotting functions using numpy arrays\nNumpy arrays are like lists, but restricted to numeric entries. This makes it possible to do fast, element-wise operations.\nExample D.56 (Features of numpy arrays)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotes:\n\nnp.linspace(a, b, N) creates N equally spaced points in [a, b].\nApplying a function to an array is done element-wise.\n\nExample D.57\nThe following code gives exactly the same output as Example D.53.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.58\nTry to use numpy arrays to plot the functions from Exercise D.48. For one of them, the code will not work. Can you imagine why?\n\n\nPredefined functions in Python\nRemark D.59 (Built-in functions in Python)\nHere is a list of some functions that are built into Python:\n\nabs(x) computes the absolute value of x.\ncomplex(a, b) returns the complex number a + ib.\nfloat(x) converts an integer to a float.\nint(x) converts a float to an integer (rounds down).\nround(a, n) rounds the floating point number a to n digits.\ntype(x) returns the datatype of the variable x.\n\nFor a full list, see https://docs.python.org/3/library/functions.html.\nRemark D.60 (Functions in the numpy package)\nTo use these functions, start your code with import numpy as np.\n\nnp.exp(x) exponential function\nnp.log(x) natural log\nnp.log2(x) log base 2\nnp.log10(x) log base 10\nnp.sin(x) sine (radians)\nnp.cos(x) cosine (radians)\nnp.tan(x) tangent (radians)\nnp.arcsin(x) arcsine\nnp.arccos(x) arccosine\nnp.arctan(x) arctangent\nnp.absolute(x) absolute value\nnp.deg2rad(x) degrees to radians\nnp.rad2deg(x) radians to degrees\nnp.sum(x) sum of elements\nnp.prod(x) product of elements\nnp.imag(z) imaginary part\nnp.real(z) real part\nnp.angle(z) angle of a complex number (radians)\nnp.conj(z) complex conjugate\n\nSome constants:\n\nnp.pi\nnp.e\n\nMore info: https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.math.html\nExample D.61\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThere are other packages with even more functions, such as math and scipy. In particular, numpy makes the math package mostly obsolete when working with numpy arrays."
  },
  {
    "objectID": "appendix_d6.html",
    "href": "appendix_d6.html",
    "title": "Appendix A.6 Answers",
    "section": "",
    "text": "Appendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_d6.html#d.6-answers-to-selected-exercises",
    "href": "appendix_d6.html#d.6-answers-to-selected-exercises",
    "title": "Appendix D.6 Answers",
    "section": "D.6 Answers to selected exercises",
    "text": "D.6 Answers to selected exercises\n\nD.4\n\n\naddition\n\n\nsubtraction\n\n\nmultiplication\n\n\npower\n\n\ndivision\n\n\nfloor division (division rounded down)\n\n\nmodulo (remainder)\n\n\n\n\nD.8\nCodes (a), (d), and (f) will not run.\n\n\nD.9\n\n\n\\(1 + 1/2 + 1/4 + 1/8 + 1/16\\)\n\n\n\\(1/(1 + 1/(1 + 1/(1 + 1/(1 + 1))))\\)\n\n\n\n\nD.11\nThe code in (a) will run.\n\n\nD.36\nThe code computes the partial sum \\(S_{99999}\\) of the harmonic series. The speed of the computations will depend on your processor.\n\n\nD.40\nHere is one solution:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nD.46\n(a) Using a for-loop and break:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b) Using a while-loop:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nD.48\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nD.49\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nD.54\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nD.58\nabsolute1 does not work for numpy arrays because the if-statement does not make sense for arrays. For absolute2, the following code works:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nD.63\nPython crashes with a ZeroDivisionError. In other words, Python really believes that \\(S_{100} = 2\\).\n\n\nD.66\nThe first 21 numbers in both binary and decimal notation:\n\n\n\nDecimal\nBinary\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n10\n\n\n3\n11\n\n\n4\n100\n\n\n5\n101\n\n\n6\n110\n\n\n7\n111\n\n\n8\n1000\n\n\n9\n1001\n\n\n10\n1010\n\n\n11\n1011\n\n\n12\n1100\n\n\n13\n1101\n\n\n14\n1110\n\n\n15\n1111\n\n\n16\n10000\n\n\n17\n10001\n\n\n18\n10010\n\n\n19\n10011\n\n\n20\n10100\n\n\n\n\n\nD.68\n\n\n\\(2^7 - 1 = 127\\)\n\n\n\\(2^{63} - 1\\)\n\n\n\n\nD.72\n\n\nRoughly \\(10^{-16}\\)\n\n\nRoughly \\(10^{-340}\\)\n\n\n\n\nD.73\nAccording to the sloppy description, \\(a + b\\) is stored as \\(3256600000000325 \\cdot 10^{17}\\). When printing 100*(a+b), 1000*(a+b) and 10000*(a+b), the 17th digit keeps changing due to round-off errors.\n\n\nD.74\n\n\n\\(N = 53\\)\n\n\n\\(N = 1075\\)\n\n\n\n\nD.76\n\n\n\\((10101)_2 = 21\\)\n\n\n\\((1010.1)_2 = 10.5\\)\n\n\n\\((10.101)_2 = 2.625\\)\n\n\n\n\nD.79\nThe exponent \\(\\alpha\\) is between \\(-1024\\) and \\(1023\\) (counting two’s complement). This means that \\(2^\\alpha\\) is between \\(10^{-308}\\) and \\(10^{308}\\), roughly. Taking into account that \\(\\epsilon\\) is between \\(1\\) and \\(10^{16}\\), and that \\((1.\\epsilon)_2\\) is replaced by \\((0.\\epsilon)_2\\) when \\(\\alpha = -1024\\), we obtain the rough description.\n\n\nD.80\nExactly the fractions \\(a / 2^n\\), where \\(a\\) is an integer and \\(n\\) is a natural number. These are the numbers with finite binary expansions."
  },
  {
    "objectID": "appendix_d3.html",
    "href": "appendix_d3.html",
    "title": "Appendix A.3 Control Statements",
    "section": "",
    "text": "Appendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_d3.html#d.3-some-additional-control-statements-in-python",
    "href": "appendix_d3.html#d.3-some-additional-control-statements-in-python",
    "title": "Appendix D.3 Control Statements",
    "section": "D.3 Some additional control statements in Python",
    "text": "D.3 Some additional control statements in Python\n\nWhile-loops\nThe while-loop is a close cousin of the for-loop. In most cases, what you can do with one of them, you can also do with the other. The point is that in most situations, one of them will usually be much easier to use than the other.\nExample D.38 (Partial sums with a while-loop)\nThe following code computes the sum \\[\\sum_{n=1}^{10} \\frac{1}{n} = 1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots + \\frac{1}{10}.\\]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nWe initialize S and n.\nThe loop continues while n &lt;= 10.\nWe must update n manually inside the loop.\n\nRemark D.39 (Logical operators)\nIn the above example, we used &lt;=. The logical operators &gt;=, ==, and != are also useful. Note that == checks equality and != checks inequality.\n\n\nExercise D.40\nUse a while-loop to check how large n has to be for the partial sums \\[S_n = \\sum_{k=0}^n \\frac{1}{2^k}\\] to be closer to 2 than 1/10000.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nIf-else statements\nAlongside for- and while-loops, the if-else statement is the most important tool in programming.\nExample D.41 (if-statements in Python)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIf you want to add more conditions, you can use elif and combine conditions using and or or.\nExample D.42\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise D.43\nUse an if-type statement to modify the code from Example D.31 (Fibonacci numbers) so that 1th, 2th, and 3th are replaced by 1st, 2nd, and 3rd.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nThe break command\nThe break command tells Python to stop the nearest loop and to continue the program on the first unindented line below it.\nExample D.44\nThe following code does exactly the same as the one in Example D.38.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nRemark D.45\nIf you have nested loops, break only stops the inner-most loop.\n\n\nExercise D.46\nConsider the list:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWrite a code that combines a for-loop with the break command to check when the first entry in the list is smaller than 1e-4.\nDo the same as in (1), but with a while-loop and no break command.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "appendix_d6.html#a.6-answers-to-selected-exercises",
    "href": "appendix_d6.html#a.6-answers-to-selected-exercises",
    "title": "Appendix A.6 Answers",
    "section": "A.6 Answers to selected exercises",
    "text": "A.6 Answers to selected exercises\n\nE.4\n\n\naddition\n\n\nsubtraction\n\n\nmultiplication\n\n\npower\n\n\ndivision\n\n\nfloor division (division rounded down)\n\n\nmodulo (remainder)\n\n\n\n\nE.8\nCodes (a), (d), and (f) will not run.\n\n\nE.9\n\n\n\\(1 + 1/2 + 1/4 + 1/8 + 1/16\\)\n\n\n\\(1/(1 + 1/(1 + 1/(1 + 1/(1 + 1))))\\)\n\n\n\n\nE.11\nThe code in (a) will run.\n\n\nE.36\nThe code computes the partial sum \\(S_{99999}\\) of the harmonic series. The speed of the computations will depend on your processor.\n\n\nE.40\nHere is one solution:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nE.46\n(a) Using a for-loop and break:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b) Using a while-loop:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nE.48\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nE.49\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nE.54\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nE.58\nabsolute1 does not work for numpy arrays because the if-statement does not make sense for arrays. For absolute2, the following code works:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nE.63\nPython crashes with a ZeroDivisionError. In other words, Python really believes that \\(S_{100} = 2\\).\n\n\nE.66\nThe first 21 numbers in both binary and decimal notation:\n\n\n\nDecimal\nBinary\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n10\n\n\n3\n11\n\n\n4\n100\n\n\n5\n101\n\n\n6\n110\n\n\n7\n111\n\n\n8\n1000\n\n\n9\n1001\n\n\n10\n1010\n\n\n11\n1011\n\n\n12\n1100\n\n\n13\n1101\n\n\n14\n1110\n\n\n15\n1111\n\n\n16\n10000\n\n\n17\n10001\n\n\n18\n10010\n\n\n19\n10011\n\n\n20\n10100\n\n\n\n\n\nE.68\n\n\n\\(2^7 - 1 = 127\\)\n\n\n\\(2^{63} - 1\\)\n\n\n\n\nE.72\n\n\nRoughly \\(10^{-16}\\)\n\n\nRoughly \\(10^{-340}\\)\n\n\n\n\nE.73\nAccording to the sloppy description, \\(a + b\\) is stored as \\(3256600000000325 \\cdot 10^{17}\\). When printing 100*(a+b), 1000*(a+b) and 10000*(a+b), the 17th digit keeps changing due to round-off errors.\n\n\nE.74\n\n\n\\(N = 53\\)\n\n\n\\(N = 1075\\)\n\n\n\n\nE.76\n\n\n\\((10101)_2 = 21\\)\n\n\n\\((1010.1)_2 = 10.5\\)\n\n\n\\((10.101)_2 = 2.625\\)\n\n\n\n\nE.79\nThe exponent \\(\\alpha\\) is between \\(-1024\\) and \\(1023\\) (counting two’s complement). This means that \\(2^\\alpha\\) is between \\(10^{-308}\\) and \\(10^{308}\\), roughly. Taking into account that \\(\\epsilon\\) is between \\(1\\) and \\(10^{16}\\), and that \\((1.\\epsilon)_2\\) is replaced by \\((0.\\epsilon)_2\\) when \\(\\alpha = -1024\\), we obtain the rough description.\n\n\nE.80\nExactly the fractions \\(a / 2^n\\), where \\(a\\) is an integer and \\(n\\) is a natural number. These are the numbers with finite binary expansions."
  },
  {
    "objectID": "appendix_d1.html#a.1-introduction",
    "href": "appendix_d1.html#a.1-introduction",
    "title": "Appendix A.1 Introduction",
    "section": "A.1 Introduction",
    "text": "A.1 Introduction\n\nHow to install Python 3 and write your first program\nGo to https://www.spyder-ide.org and download and install the latest version of Spyder.\nOnce installed, launch the program.\n\n\n\n\n\n\nNote\n\n\n\nFigure omitted in this web version.\n\n\n\nExercise E.1\nType print(\"Hello world\") in the editor window and press the green play button.\nWhat output do you get? Also try print(\"2+2=\", 2+2).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nRemark. Python treats \"2+2\" as text to be printed, and 2+2 as something to be computed. A comma is used to separate different types of input to print.\n\n\n\n\n\nA first look at basic syntax for arithmetic in Python\nWe now consider how to do basic arithmetic in Python.\nExample E.2 Enter the following code into the Spyder editor.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen you press the green play button you get the output a+b=6.\nHere, a, b, and c are variables. Technically speaking, a variable is a space in the memory of the computer which can store one piece of information, such as a number.\nExample E.3 Enter the following code into the Spyder editor.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen you press the green play button you still get the output a+b=6.\nLine-by-line explanation of Example E.2:\n\nPython creates a variable a and assigns it the value 2.\nPython creates a variable b and assigns it the value 4.\nPython creates a variable c, computes a + b, and assigns this value to c.\nPython prints the value of c on the screen (together with the string \"a+b=\").\n\nThe above example illustrates several peculiarities of arithmetic in Python and how a code is run:\n\nThe code is executed line by line.\nExpressions such as a = b should be read from right to left. That is, a is assigned whatever value b has, but not vice versa.\nIf a variable gets assigned some value, it has no memory of how that happened. Changing a later does not affect the value stored in c.\n\n\nExercise E.4\nExplore the various ways to do arithmetic operations in Python by running the following commands for suitable values of a and b:\na + b, a * b, a - b, a - -b, a / b, a // b, a % b.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nBasic rules for variable names\nWe now turn to a discussion of the basic syntax in Python. First, the types of names you are allowed to give a variable.\nExample E.5 You can give variables much more interesting names than just a, b, x, or y. Here is an example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe make the following remarks:\n\nPython is case sensitive. This means that n and N are as different as n and m.\nBy tradition, the name of a variable should never start with an upper case letter.\nA variable cannot be given a numerical name such as 2 or 34. Numbers can be part of the name of a variable, as long as the name starts with a letter or an underscore _. Certain special symbols, such as $, #, and %, can never be used in the name of a variable.\nThe name of a variable cannot contain a space.\nYou should not give a variable a name that already means something different. For instance, do not give a variable the name print (however, Print is fine).\n\n\n\nIndentation, line breaks, and comments\nExample E.6 In Python, we need to be careful with how we place indentations. For instance, both of the following programs will crash:\na = 2\nb = 4\n    c = a + b\nprint(c)\na = 2\nb = 4\nc = a + b\n  print(c)\n\nPython is careful with indentation. If Python does not understand why we make some indentation, it will crash.\nLater in this chapter, we will see situations where indentations become a natural part of the code (for loops, while loops, if-else structures, and functions).\n\nExample E.7 In contrast to the situation with indentations, Python is much less sensitive with respect to whether or not we skip a line. The following code runs just fine:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPython does not care if you skip a line, or twenty.\nYou can place multiple commands on the same line, as long as they are separated by a semicolon ;.\nEverything you write on a line following a hashtag # is ignored by Python.\nYou can use “soft” parentheses ( and ) just as you would in a normal computation. You cannot replace them with [ ] or { }.\nIt is a good thing for a program to crash. It is a way for Python to let you know that the result would probably have been false because the code was written in a bad way.\n\n\nExercise E.8\nWill the following codes run? If not, why? If yes, what is the output?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(c)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(d)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(e)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(f)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise E.9\nConsider the following codes. Can you express mathematically what they compute?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nHint: You have already seen these objects on page 87.\n\n\n\nA first look at how to efficiently repeat commands in Python\nIn Exercise E.9 above, you were asked to consider a code where an operation was repeated multiple times. We now explain one way this can be done using a for loop.\nExample E.10 (For-loop) The following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of the for loop:\n\nfor n in range(0, 4) means the block below is repeated for each n between 0 and 3 (but not 4).\nThe indented lines are run by the loop. The loop first runs with n = 0, then n = 1, and so on until n = 3.\nAfter the loop ends, Python moves on to the first unindented line following it.\n\n\nExercise E.11\nWill these codes run? If so, what are their outputs?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise E.12\nRewrite the code in Exercise E.9 using for loops.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nSome words on datatypes in Python\nPython stores variables in different ways depending on whether they contain text, numbers, or lists. We say that Python uses different datatypes. For instance, Python will treat a number differently depending on whether or not it is an integer.\nExample E.13\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExercise E.14\n\nCheck the type of the variable defined by b = 3/2.\nCheck the type of the variable defined by c = 4/2.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn addition to integers and floating point numbers, we will encounter the following datatypes in this chapter:\n\nString: a variable containing text, e.g. a = \"Hej\".\nList: a variable containing a list of other variables, e.g. a = [2, 3/2, \"Hej\"].\nNumpy array: a special type of list that can only contain integers or floating point numbers (and has more advanced features).\n\n\n\n\nHow to store and manipulate sequences using Python lists\nOne way of storing sequences in Python is by using lists.\nExample E.16\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe code is more or less explained by the comments, but we note:\n\nUse square brackets [ ] to create a list and commas , to separate entries.\nWriting a[3] = 10 changes an entry in the list.\nlen, sum, max, and min work only if the list contains numbers.\nLists are easy to modify with append, pop, concatenation, and slicing."
  },
  {
    "objectID": "appendix_d2.html#a.2-how-to-compute-and-visualize-sequences-and-sums",
    "href": "appendix_d2.html#a.2-how-to-compute-and-visualize-sequences-and-sums",
    "title": "Appendix A.2 Sequences and Sums",
    "section": "A.2 How to compute and visualize sequences and sums",
    "text": "A.2 How to compute and visualize sequences and sums\n\nSome ways to compute sequences in Python\nSuppose we want to compute many entries of the sequence \\[\\left(\\frac{1}{2^k}\\right)_{k=0}^\\infty = \\left(1, \\frac{1}{2}, \\frac{1}{4}, \\dots \\right).\\]\nExample E.17 (Computing sequences using a for-loop)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAnother way of computing lists is to use a list comprehension. It has the benefit of both computing and storing a sequence of numbers in a single line of code.\nExample E.18 (Computing sequences using a list)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExercise E.19\nRun and compare the output of the codes in the above examples.\n\n\nExercise E.20\nA difference between the right-most codes in Examples E.17 and E.18 is that in the first, we do not store the values of the sequence anywhere. Here are two suggestions for how to fix this:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplain what is going on in each code. What information is stored at the end of each program? Also, why do these not give any output? Can you fix this?\n\n\n\nSome ways to compute partial sums of infinite series\nOn the previous page, we discussed how to compute and store values of a sequence. Let us now consider how to compute the sum of the first, say, million terms of the infinite series \\[\\sum_{k=0}^{\\infty} \\frac{1}{2^k} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\cdots.\\]\nExample E.21 (Computing sums using a for-loop)\nThe following two codes both compute the sum \\(1 + 1/2 + 1/4 + 1/8\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample E.22 (Computing a sum using lists)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing this technique, we can compute the sum in just one line:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExercise E.23\n\nRun the codes from the examples on this page. Why do they not give any output? Fix this.\nModify the code so that you can compute the sum of the first million terms or so. What result do you get?\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nHow to visualize sequences and partial sums using for-loops\nExample E.24\nThe following code is perhaps the simplest way to visualize a sequence in Python. Here, we visualize the sequence \\((1/2^k)_{k=0}^9\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nmatplotlib.pyplot provides plotting commands.\nThe for loop plots a blue dot at \\((k, 1/2^k)\\) for each k.\nplt.show() displays the figure.\n\nNow modify the code so that we plot partial sums of the infinite series \\[\\sum_{k=0}^\\infty \\frac{1}{2^k}.\\]\nExample E.25\nThe following code computes and visualizes the partial sums.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExercise E.26\nRun this code, and verify by computing the first three partial sums by hand that the plot is correct. What happens when you increase range(0, 3) to, say, range(0, 100)?\n\n\nExercise E.27\nSeveral commands can be used to change how the above figure looks. Try inserting the following into the code anywhere after the import and before plt.plot. What happens?\n\nReplace \"bo\" by \"rx\".\nplt.xlim(-3, 15)\nplt.ylim(-5, 2)\nplt.xlabel(\"There was\")\nplt.ylabel(\"a graph\")\nplt.title(\"that had a title\")\nplt.xticks([-2, 0, 3, 4, 6.5, 10])\nplt.yticks([0, 1, 1.5])\nplt.grid(True)\nplt.figure(figsize=(4, 3))\nplt.savefig(\"myfigure.jpg\")\n\nRemark: Note that by choosing the extension .jpg, you tell Python to save your figure as a jpg file. Only a limited number of file formats are supported.\n\n\n\nVisualizing sequences and partial sums stored as lists\nExample E.28\nWe now use lists to create and plot the sequence \\((1/2^n)_{n=0}^9\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nn_values gives the x-axis values.\na stores the sequence values.\nplt.plot(n_values, a, \"bo\") plots the points.\n\nExample E.29\nWe now use lists to compute and plot partial sums of \\[\\sum_{k=0}^\\infty \\frac{1}{2^k}.\\]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe key line is the list comprehension: S = [sum(a[0:n + 1]) for n in indices]. Remember that a[0:n + 1] contains the entries a[0], a[1], ..., a[n].\n\nExercise E.30\nImplement the code in Example E.29. Verify that it gives the same output as Example E.25 when the range in the latter example is suitably adjusted.\n\n\n\nA slightly more advanced example: the Fibonacci sequence\nThe Fibonacci numbers are \\[1, 1, 2, 3, 5, 8, 13, \\dots\\] and satisfy \\(a_n = a_{n-1} + a_{n-2}\\) for \\(n \\ge 2\\) when we set \\(a_0 = 1\\) and \\(a_1 = 1\\).\nExample E.31\nThe following code can be used to compute Fibonacci numbers.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExercise E.32\nImplement the code from the above example. Use a reference (for example, a list of Fibonacci numbers) to verify that it gives the correct output.\n\n\nExercise E.33\nUse the method of the above examples to create a list containing a few partial sums of the infinite series \\(\\sum_{k=0}^\\infty 1/2^k\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nRemark R.34 (for-loops versus list comprehensions)\nPure for-loops are available in most programming languages, while list comprehensions are specific to Python. If you want to adapt to other languages, use list comprehensions sparingly.\n\n\nRemark R.35 (how to time a computation)\nYou can measure how long it takes for a program to run. Here is how:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise E.36\nConsider the code:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWhat does the code compute?\nDo the same as in (1), except by first creating a sequence a and then computing its sum using sum(a).\nUse the timing code above to compare which method is fastest.\n\n\n\nRemark R.37\nPython is useful but fairly slow. Built-in commands are usually implemented in faster languages (such as C++), so if speed is important, use built-in functions as much as possible."
  },
  {
    "objectID": "appendix_d4.html#a.4-functions-in-python",
    "href": "appendix_d4.html#a.4-functions-in-python",
    "title": "Appendix A.4 Functions",
    "section": "A.4 Functions in Python",
    "text": "A.4 Functions in Python\n\nHow to define a function in Python\nExample E.47 (Defining functions in Python)\nIn the following code we define \\(f(x) = x^2 - 5x + 4\\) in Python and compute \\(f(3)\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\ndef f(x): tells Python that a function named f is being defined.\nThe return value is the output of the function.\nWhen we write f(3), the function code is run with x = 3.\n\n\nExercise E.48\n\nUse the if-control statement to implement the absolute value function. Use it on a few values to check that it works.\nImplement the absolute value function without using the if-control statement.\n\nRemark: It is not really necessary to program the absolute value function by hand since it already exists in Python as abs(x).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise E.49\nWrite the code for a function that will take a list of numbers as input and return their product as output. This is analogous to the built-in function sum() which returns the sum.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nWarning: the importance of local namespaces\nVariables created inside a function are local and cannot be accessed outside the function. This is a common source of bugs.\nExample E.50\nThe following code makes no sense and will crash.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample E.51\nThe following code also crashes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe variable y only exists inside the function definition. After the function returns, local variables are deleted.\nExample E.52\nThanks to local namespaces, we can be sure that the following code works:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nHow to plot functions in Python using lists\nExample E.53 (Plotting with datatype list)\nThe following code plots \\(f(x) = x^2 + 2x + 3\\) over the interval \\([0, 1]\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe command plt.plot(X, Y) connects the points with straight line segments. If you use plt.plot(X, Y, \"bo\") you will get blue dots instead of a line.\n\nExercise E.54\nPlot the functions you implemented in Exercise E.48 on \\([1/2, 2]\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExercise E.55\nConsider the following code:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExplain in mathematical terms what this code does.\nThe symbol a takes more than one role in the above code. Explain what roles these are.\nMake the code easier to read by giving a different names where possible.\n\n\n\n\nPlotting functions using numpy arrays\nNumpy arrays are like lists, but restricted to numeric entries. This makes it possible to do fast, element-wise operations.\nExample E.56 (Features of numpy arrays)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotes:\n\nnp.linspace(a, b, N) creates N equally spaced points in [a, b].\nApplying a function to an array is done element-wise.\n\nExample E.57\nThe following code gives exactly the same output as Example E.53.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExercise E.58\nTry to use numpy arrays to plot the functions from Exercise E.48. For one of them, the code will not work. Can you imagine why?\n\n\n\nPredefined functions in Python\nRemark R.59 (Built-in functions in Python)\nHere is a list of some functions that are built into Python:\n\nabs(x) computes the absolute value of x.\ncomplex(a, b) returns the complex number a + ib.\nfloat(x) converts an integer to a float.\nint(x) converts a float to an integer (rounds down).\nround(a, n) rounds the floating point number a to n digits.\ntype(x) returns the datatype of the variable x.\n\nFor a full list, see https://docs.python.org/3/library/functions.html.\nRemark R.60 (Functions in the numpy package)\nTo use these functions, start your code with import numpy as np.\n\nnp.exp(x) exponential function\nnp.log(x) natural log\nnp.log2(x) log base 2\nnp.log10(x) log base 10\nnp.sin(x) sine (radians)\nnp.cos(x) cosine (radians)\nnp.tan(x) tangent (radians)\nnp.arcsin(x) arcsine\nnp.arccos(x) arccosine\nnp.arctan(x) arctangent\nnp.absolute(x) absolute value\nnp.deg2rad(x) degrees to radians\nnp.rad2deg(x) radians to degrees\nnp.sum(x) sum of elements\nnp.prod(x) product of elements\nnp.imag(z) imaginary part\nnp.real(z) real part\nnp.angle(z) angle of a complex number (radians)\nnp.conj(z) complex conjugate\n\nSome constants:\n\nnp.pi\nnp.e\n\nMore info: https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.math.html\nExample E.61\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThere are other packages with even more functions, such as math and scipy. In particular, numpy makes the math package mostly obsolete when working with numpy arrays."
  },
  {
    "objectID": "appendix_d5.html#a.5-how-numbers-are-represented-in-python",
    "href": "appendix_d5.html#a.5-how-numbers-are-represented-in-python",
    "title": "Appendix A.5 Number Representation",
    "section": "A.5 How numbers are represented in Python",
    "text": "A.5 How numbers are represented in Python\nWe end this appendix by examining how numbers are represented in Python and some peculiar consequences of this.\nExample E.62\nAt the start of Chapter 3, we considered the infinite series \\[\\sum_{k=0}^{\\infty} \\frac{1}{2^k} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\cdots.\\]\nLet \\(S_n\\) denote the \\(n\\)th partial sum. The point is that \\(2 - S_n = 1/2^n\\), so \\(S_n \\ne 2\\). But if we ask Python to compute, say, \\(S_{100}\\), it returns 2.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.63\nDoes Python really mean that \\(S_{100} = 2\\), or is there something else going on? One way to double check is to ask Python to compute \\(1 / (2 - S_{100})\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nHow integers are represented in Python\nIf we run\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPython stores the integer using a fixed number of bits (modern computers typically use 64 bits for integers).\n\n\n\n\n\n\nNote\n\n\n\nFigures omitted in this web version.\n\n\nExample E.65 (Decimal and binary notation)\nIn decimal: \\[4132 = 4\\cdot10^3 + 1\\cdot10^2 + 3\\cdot10^1 + 2\\cdot10^0.\\]\nIn binary: \\[1101_2 = 1\\cdot2^3 + 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0.\\]\nIf it is not clear whether a number is written in binary or decimal, we can use the notations \\((1101)_2\\) and \\((1101)_{10}\\).\nCounting in binary: \\((0)_2=0\\), \\((1)_2=1\\), \\((10)_2=2\\), \\((11)_2=3\\), \\((100)_2=4\\), \\((101)_2=5\\), \\((110)_2=6\\), \\((111)_2=7\\), \\((1000)_2=8\\), and so on.\nExercise E.66\nCheck that the above list is correct, and continue the list to 20.\nExercise E.68\n\nWhat is the largest integer you can represent as an 8-bit integer?\nModern computers use 64-bit integers, where 1 bit is used for the sign and 63 for the number itself. What is the largest integer you can represent using a 64-bit integer?\n\nRemark R.69 (Two’s complement)\nOur explanation above is correct for positive integers. For negative integers, a strategy called two’s complement is used. For an 8-bit integer, this allows representation of integers from -128 to 127.\n\n\nHow non-integers are represented in Python\nReal numbers that are not integers are stored using the datatype float. Because memory is finite, not all real numbers can be represented exactly.\nRemark R.70 (Sloppy description of 64-bit floating numbers)\nA 64-bit computer sets aside 64 bits to represent a real number of the form \\(\\epsilon \\cdot 10^\\alpha\\), where \\(\\epsilon\\) is (roughly) a 16-digit integer and the exponent \\(\\alpha\\) is roughly between -340 and +292.\nExample E.71\nUsing the sloppy description, the number \\(\\sqrt{2}\\) is stored roughly as \\[1.414213562373095 \\cdot 10^0.\\]\nExercise E.72\nAccording to the sloppy definition:\n\nHow far is it between the floating point representation of \\(\\sqrt{2}\\) and its closest floating point neighbor?\nHow far is it between \\(x=0\\) and the next floating point number?\n\nExercise E.73\nPut a = 325660000, b = 0.000032566 and use Python to compute 100*(a+b), 1000*(a+b), and 10000*(a+b). How are the results stored? Are there any round-off errors?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.74\nUse the sloppy description of float numbers to do the following:\n\nExplain how large N has to be for the computer to think that \\(1 + 2^{-N} = 1\\).\nHow large does N have to be for the computer to think that \\(2^{-N} = 0\\)?\n\nExample E.75 (Binary notation for non-integers)\nBinary notation for non-integers works like decimal notation. Compare: \\[643.57_{10} = 6\\cdot10^2 + 4\\cdot10^1 + 3\\cdot10^0 + 5\\cdot10^{-1} + 7\\cdot10^{-2}\\] and \\[101.01_2 = 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2}.\\]\nExercise E.76\nAs a small taste of binary arithmetic, figure out both the decimal and binary representations of:\n\n\\((101.01)_2 \\cdot 2^2\\)\n\\((101.01)_2 \\cdot 2^1\\)\n\\((101.01)_2 \\cdot 2^{-1}\\)\n\nRemark R.77 (Accurate description of 64-bit floating point numbers)\nA 64-bit floating point number is stored in the form \\[(1.\\epsilon)_2 \\cdot 2^\\alpha,\\] where \\(\\epsilon\\) is a string of 52 bits and the exponent \\(\\alpha\\) is an 11-bit integer. The remaining bit is used for the sign.\nWhen the exponent \\(\\alpha\\) is the smallest possible, \\((1.\\epsilon)_2\\) is replaced by \\((0.\\epsilon)_2\\) to offer additional accuracy close to the origin.\n\n\n\n\n\n\nNote\n\n\n\nFigures omitted in this web version.\n\n\nExample E.78\nHow do we store \\(1/10\\) as a floating point number? The binary expansion of \\(1/10\\) is \\[0.00011001100110011\\ldots_2\\] which is repeating. This means it cannot be stored exactly, so we must round.\nExercise E.79\nTranslate the accurate description of 64-bit floating point numbers to decimal notation to obtain the sloppy description above. Take into account the added accuracy close to the origin.\nExercise E.80 (Challenging)\nExplain which fractions can be represented without round-off error as 64-bit floating point numbers.\nRemark R.81 (The effect of round-off errors)\nWhen using Python to compute and visualize data, we must consider whether results are real or caused by round-off error. This is especially important for functions with large or small scales."
  },
  {
    "objectID": "appendix_d3.html#a.3-some-additional-control-statements-in-python",
    "href": "appendix_d3.html#a.3-some-additional-control-statements-in-python",
    "title": "Appendix A.3 Control Statements",
    "section": "A.3 Some additional control statements in Python",
    "text": "A.3 Some additional control statements in Python\n\nWhile-loops\nThe while-loop is a close cousin of the for-loop. In most cases, what you can do with one of them, you can also do with the other. The point is that in most situations, one of them will usually be much easier to use than the other.\nExample E.38 (Partial sums with a while-loop)\nThe following code computes the sum \\[\\sum_{n=1}^{10} \\frac{1}{n} = 1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots + \\frac{1}{10}.\\]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nWe initialize S and n.\nThe loop continues while n &lt;= 10.\nWe must update n manually inside the loop.\n\nRemark R.39 (Logical operators)\nIn the above example, we used &lt;=. The logical operators &gt;=, ==, and != are also useful. Note that == checks equality and != checks inequality.\n\nExercise E.40\nUse a while-loop to check how large n has to be for the partial sums \\[S_n = \\sum_{k=0}^n \\frac{1}{2^k}\\] to be closer to 2 than 1/10000.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIf-else statements\nAlongside for- and while-loops, the if-else statement is the most important tool in programming.\nExample E.41 (if-statements in Python)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIf you want to add more conditions, you can use elif and combine conditions using and or or.\nExample E.42\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExercise E.43\nUse an if-type statement to modify the code from Example E.31 (Fibonacci numbers) so that 1th, 2th, and 3th are replaced by 1st, 2nd, and 3rd.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThe break command\nThe break command tells Python to stop the nearest loop and to continue the program on the first unindented line below it.\nExample E.44\nThe following code does exactly the same as the one in Example E.38.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nRemark R.45\nIf you have nested loops, break only stops the inner-most loop.\n\nExercise E.46\nConsider the list:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWrite a code that combines a for-loop with the break command to check when the first entry in the list is smaller than 1e-4.\nDo the same as in (1), but with a while-loop and no break command.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "appendix_all.html",
    "href": "appendix_all.html",
    "title": "Appendix A (All)",
    "section": "",
    "text": "Appendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_all.html#a.1-introduction",
    "href": "appendix_all.html#a.1-introduction",
    "title": "Appendix A (All)",
    "section": "A.1 Introduction",
    "text": "A.1 Introduction\n\nHow to install Python 3 and write your first program\nGo to https://www.spyder-ide.org and download and install the latest version of Spyder.\nOnce installed, launch the program.\n\n\n\n\n\n\nNote\n\n\n\nFigure omitted in this web version.\n\n\nExercise E.1\nType print(\"Hello world\") in the editor window and press the green play button.\nWhat output do you get? Also try print(\"2+2=\", 2+2).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nRemark. Python treats \"2+2\" as text to be printed, and 2+2 as something to be computed. A comma is used to separate different types of input to print.\n\n\n\n\nA first look at basic syntax for arithmetic in Python\nWe now consider how to do basic arithmetic in Python.\nExample E.2 Enter the following code into the Spyder editor.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen you press the green play button you get the output a+b=6.\nHere, a, b, and c are variables. Technically speaking, a variable is a space in the memory of the computer which can store one piece of information, such as a number.\nExample E.3 Enter the following code into the Spyder editor.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen you press the green play button you still get the output a+b=6.\nLine-by-line explanation of Example E.2:\n\nPython creates a variable a and assigns it the value 2.\nPython creates a variable b and assigns it the value 4.\nPython creates a variable c, computes a + b, and assigns this value to c.\nPython prints the value of c on the screen (together with the string \"a+b=\").\n\nThe above example illustrates several peculiarities of arithmetic in Python and how a code is run:\n\nThe code is executed line by line.\nExpressions such as a = b should be read from right to left. That is, a is assigned whatever value b has, but not vice versa.\nIf a variable gets assigned some value, it has no memory of how that happened. Changing a later does not affect the value stored in c.\n\nExercise E.4\nExplore the various ways to do arithmetic operations in Python by running the following commands for suitable values of a and b:\na + b, a * b, a - b, a - -b, a / b, a // b, a % b.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nBasic rules for variable names\nWe now turn to a discussion of the basic syntax in Python. First, the types of names you are allowed to give a variable.\nExample E.5 You can give variables much more interesting names than just a, b, x, or y. Here is an example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe make the following remarks:\n\nPython is case sensitive. This means that n and N are as different as n and m.\nBy tradition, the name of a variable should never start with an upper case letter.\nA variable cannot be given a numerical name such as 2 or 34. Numbers can be part of the name of a variable, as long as the name starts with a letter or an underscore _. Certain special symbols, such as $, #, and %, can never be used in the name of a variable.\nThe name of a variable cannot contain a space.\nYou should not give a variable a name that already means something different. For instance, do not give a variable the name print (however, Print is fine).\n\n\n\nIndentation, line breaks, and comments\nExample E.6 In Python, we need to be careful with how we place indentations. For instance, both of the following programs will crash:\na = 2\nb = 4\n    c = a + b\nprint(c)\na = 2\nb = 4\nc = a + b\n  print(c)\n\nPython is careful with indentation. If Python does not understand why we make some indentation, it will crash.\nLater in this chapter, we will see situations where indentations become a natural part of the code (for loops, while loops, if-else structures, and functions).\n\nExample E.7 In contrast to the situation with indentations, Python is much less sensitive with respect to whether or not we skip a line. The following code runs just fine:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPython does not care if you skip a line, or twenty.\nYou can place multiple commands on the same line, as long as they are separated by a semicolon ;.\nEverything you write on a line following a hashtag # is ignored by Python.\nYou can use “soft” parentheses ( and ) just as you would in a normal computation. You cannot replace them with [ ] or { }.\nIt is a good thing for a program to crash. It is a way for Python to let you know that the result would probably have been false because the code was written in a bad way.\n\nExercise E.8\nWill the following codes run? If not, why? If yes, what is the output?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(c)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(d)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(e)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(f)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.9\nConsider the following codes. Can you express mathematically what they compute?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nHint: You have already seen these objects on page 87.\n\n\nA first look at how to efficiently repeat commands in Python\nIn Exercise E.9 above, you were asked to consider a code where an operation was repeated multiple times. We now explain one way this can be done using a for loop.\nExample E.10 (For-loop) The following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of the for loop:\n\nfor n in range(0, 4) means the block below is repeated for each n between 0 and 3 (but not 4).\nThe indented lines are run by the loop. The loop first runs with n = 0, then n = 1, and so on until n = 3.\nAfter the loop ends, Python moves on to the first unindented line following it.\n\nExercise E.11\nWill these codes run? If so, what are their outputs?\n(a)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.12\nRewrite the code in Exercise E.9 using for loops.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nSome words on datatypes in Python\nPython stores variables in different ways depending on whether they contain text, numbers, or lists. We say that Python uses different datatypes. For instance, Python will treat a number differently depending on whether or not it is an integer.\nExample E.13\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.14\n\nCheck the type of the variable defined by b = 3/2.\nCheck the type of the variable defined by c = 4/2.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn addition to integers and floating point numbers, we will encounter the following datatypes in this chapter:\n\nString: a variable containing text, e.g. a = \"Hej\".\nList: a variable containing a list of other variables, e.g. a = [2, 3/2, \"Hej\"].\nNumpy array: a special type of list that can only contain integers or floating point numbers (and has more advanced features).\n\n\n\nHow to store and manipulate sequences using Python lists\nOne way of storing sequences in Python is by using lists.\nExample E.16\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe code is more or less explained by the comments, but we note:\n\nUse square brackets [ ] to create a list and commas , to separate entries.\nWriting a[3] = 10 changes an entry in the list.\nlen, sum, max, and min work only if the list contains numbers.\nLists are easy to modify with append, pop, concatenation, and slicing.\n\nAppendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_all.html#a.2-how-to-compute-and-visualize-sequences-and-sums",
    "href": "appendix_all.html#a.2-how-to-compute-and-visualize-sequences-and-sums",
    "title": "Appendix A (All)",
    "section": "A.2 How to compute and visualize sequences and sums",
    "text": "A.2 How to compute and visualize sequences and sums\n\nSome ways to compute sequences in Python\nSuppose we want to compute many entries of the sequence \\[\\left(\\frac{1}{2^k}\\right)_{k=0}^\\infty = \\left(1, \\frac{1}{2}, \\frac{1}{4}, \\dots \\right).\\]\nExample E.17 (Computing sequences using a for-loop)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAnother way of computing lists is to use a list comprehension. It has the benefit of both computing and storing a sequence of numbers in a single line of code.\nExample E.18 (Computing sequences using a list)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.19\nRun and compare the output of the codes in the above examples.\nExercise E.20\nA difference between the right-most codes in Examples E.17 and E.18 is that in the first, we do not store the values of the sequence anywhere. Here are two suggestions for how to fix this:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplain what is going on in each code. What information is stored at the end of each program? Also, why do these not give any output? Can you fix this?\n\n\nSome ways to compute partial sums of infinite series\nOn the previous page, we discussed how to compute and store values of a sequence. Let us now consider how to compute the sum of the first, say, million terms of the infinite series \\[\\sum_{k=0}^{\\infty} \\frac{1}{2^k} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\cdots.\\]\nExample E.21 (Computing sums using a for-loop)\nThe following two codes both compute the sum \\(1 + 1/2 + 1/4 + 1/8\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample E.22 (Computing a sum using lists)\nThe following two codes do exactly the same thing when run.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing this technique, we can compute the sum in just one line:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.23\n\nRun the codes from the examples on this page. Why do they not give any output? Fix this.\nModify the code so that you can compute the sum of the first million terms or so. What result do you get?\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nHow to visualize sequences and partial sums using for-loops\nExample E.24\nThe following code is perhaps the simplest way to visualize a sequence in Python. Here, we visualize the sequence \\((1/2^k)_{k=0}^9\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nmatplotlib.pyplot provides plotting commands.\nThe for loop plots a blue dot at \\((k, 1/2^k)\\) for each k.\nplt.show() displays the figure.\n\nNow modify the code so that we plot partial sums of the infinite series \\[\\sum_{k=0}^\\infty \\frac{1}{2^k}.\\]\nExample E.25\nThe following code computes and visualizes the partial sums.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.26\nRun this code, and verify by computing the first three partial sums by hand that the plot is correct. What happens when you increase range(0, 3) to, say, range(0, 100)?\nExercise E.27\nSeveral commands can be used to change how the above figure looks. Try inserting the following into the code anywhere after the import and before plt.plot. What happens?\n\nReplace \"bo\" by \"rx\".\nplt.xlim(-3, 15)\nplt.ylim(-5, 2)\nplt.xlabel(\"There was\")\nplt.ylabel(\"a graph\")\nplt.title(\"that had a title\")\nplt.xticks([-2, 0, 3, 4, 6.5, 10])\nplt.yticks([0, 1, 1.5])\nplt.grid(True)\nplt.figure(figsize=(4, 3))\nplt.savefig(\"myfigure.jpg\")\n\nRemark: Note that by choosing the extension .jpg, you tell Python to save your figure as a jpg file. Only a limited number of file formats are supported.\n\n\nVisualizing sequences and partial sums stored as lists\nExample E.28\nWe now use lists to create and plot the sequence \\((1/2^n)_{n=0}^9\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nn_values gives the x-axis values.\na stores the sequence values.\nplt.plot(n_values, a, \"bo\") plots the points.\n\nExample E.29\nWe now use lists to compute and plot partial sums of \\[\\sum_{k=0}^\\infty \\frac{1}{2^k}.\\]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe key line is the list comprehension: S = [sum(a[0:n + 1]) for n in indices]. Remember that a[0:n + 1] contains the entries a[0], a[1], ..., a[n].\nExercise E.30\nImplement the code in Example E.29. Verify that it gives the same output as Example E.25 when the range in the latter example is suitably adjusted.\n\n\nA slightly more advanced example: the Fibonacci sequence\nThe Fibonacci numbers are \\[1, 1, 2, 3, 5, 8, 13, \\dots\\] and satisfy \\(a_n = a_{n-1} + a_{n-2}\\) for \\(n \\ge 2\\) when we set \\(a_0 = 1\\) and \\(a_1 = 1\\).\nExample E.31\nThe following code can be used to compute Fibonacci numbers.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.32\nImplement the code from the above example. Use a reference (for example, a list of Fibonacci numbers) to verify that it gives the correct output.\nExercise E.33\nUse the method of the above examples to create a list containing a few partial sums of the infinite series \\(\\sum_{k=0}^\\infty 1/2^k\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nRemark R.34 (for-loops versus list comprehensions)\nPure for-loops are available in most programming languages, while list comprehensions are specific to Python. If you want to adapt to other languages, use list comprehensions sparingly.\nRemark R.35 (how to time a computation)\nYou can measure how long it takes for a program to run. Here is how:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.36\nConsider the code:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWhat does the code compute?\nDo the same as in (1), except by first creating a sequence a and then computing its sum using sum(a).\nUse the timing code above to compare which method is fastest.\n\nRemark R.37\nPython is useful but fairly slow. Built-in commands are usually implemented in faster languages (such as C++), so if speed is important, use built-in functions as much as possible.\nAppendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_all.html#a.3-some-additional-control-statements-in-python",
    "href": "appendix_all.html#a.3-some-additional-control-statements-in-python",
    "title": "Appendix A (All)",
    "section": "A.3 Some additional control statements in Python",
    "text": "A.3 Some additional control statements in Python\n\nWhile-loops\nThe while-loop is a close cousin of the for-loop. In most cases, what you can do with one of them, you can also do with the other. The point is that in most situations, one of them will usually be much easier to use than the other.\nExample E.38 (Partial sums with a while-loop)\nThe following code computes the sum \\[\\sum_{n=1}^{10} \\frac{1}{n} = 1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots + \\frac{1}{10}.\\]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\nWe initialize S and n.\nThe loop continues while n &lt;= 10.\nWe must update n manually inside the loop.\n\nRemark R.39 (Logical operators)\nIn the above example, we used &lt;=. The logical operators &gt;=, ==, and != are also useful. Note that == checks equality and != checks inequality.\nExercise E.40\nUse a while-loop to check how large n has to be for the partial sums \\[S_n = \\sum_{k=0}^n \\frac{1}{2^k}\\] to be closer to 2 than 1/10000.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nIf-else statements\nAlongside for- and while-loops, the if-else statement is the most important tool in programming.\nExample E.41 (if-statements in Python)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIf you want to add more conditions, you can use elif and combine conditions using and or or.\nExample E.42\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.43\nUse an if-type statement to modify the code from Example E.31 (Fibonacci numbers) so that 1th, 2th, and 3th are replaced by 1st, 2nd, and 3rd.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nThe break command\nThe break command tells Python to stop the nearest loop and to continue the program on the first unindented line below it.\nExample E.44\nThe following code does exactly the same as the one in Example E.38.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nRemark R.45\nIf you have nested loops, break only stops the inner-most loop.\nExercise E.46\nConsider the list:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWrite a code that combines a for-loop with the break command to check when the first entry in the list is smaller than 1e-4.\nDo the same as in (1), but with a while-loop and no break command.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAppendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_all.html#a.4-functions-in-python",
    "href": "appendix_all.html#a.4-functions-in-python",
    "title": "Appendix A (All)",
    "section": "A.4 Functions in Python",
    "text": "A.4 Functions in Python\n\nHow to define a function in Python\nExample E.47 (Defining functions in Python)\nIn the following code we define \\(f(x) = x^2 - 5x + 4\\) in Python and compute \\(f(3)\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation:\n\ndef f(x): tells Python that a function named f is being defined.\nThe return value is the output of the function.\nWhen we write f(3), the function code is run with x = 3.\n\nExercise E.48\n\nUse the if-control statement to implement the absolute value function. Use it on a few values to check that it works.\nImplement the absolute value function without using the if-control statement.\n\nRemark: It is not really necessary to program the absolute value function by hand since it already exists in Python as abs(x).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.49\nWrite the code for a function that will take a list of numbers as input and return their product as output. This is analogous to the built-in function sum() which returns the sum.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nWarning: the importance of local namespaces\nVariables created inside a function are local and cannot be accessed outside the function. This is a common source of bugs.\nExample E.50\nThe following code makes no sense and will crash.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExample E.51\nThe following code also crashes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe variable y only exists inside the function definition. After the function returns, local variables are deleted.\nExample E.52\nThanks to local namespaces, we can be sure that the following code works:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nHow to plot functions in Python using lists\nExample E.53 (Plotting with datatype list)\nThe following code plots \\(f(x) = x^2 + 2x + 3\\) over the interval \\([0, 1]\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe command plt.plot(X, Y) connects the points with straight line segments. If you use plt.plot(X, Y, \"bo\") you will get blue dots instead of a line.\nExercise E.54\nPlot the functions you implemented in Exercise E.48 on \\([1/2, 2]\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.55\nConsider the following code:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nExplain in mathematical terms what this code does.\nThe symbol a takes more than one role in the above code. Explain what roles these are.\nMake the code easier to read by giving a different names where possible.\n\n\n\nPlotting functions using numpy arrays\nNumpy arrays are like lists, but restricted to numeric entries. This makes it possible to do fast, element-wise operations.\nExample E.56 (Features of numpy arrays)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotes:\n\nnp.linspace(a, b, N) creates N equally spaced points in [a, b].\nApplying a function to an array is done element-wise.\n\nExample E.57\nThe following code gives exactly the same output as Example E.53.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.58\nTry to use numpy arrays to plot the functions from Exercise E.48. For one of them, the code will not work. Can you imagine why?\n\n\nPredefined functions in Python\nRemark R.59 (Built-in functions in Python)\nHere is a list of some functions that are built into Python:\n\nabs(x) computes the absolute value of x.\ncomplex(a, b) returns the complex number a + ib.\nfloat(x) converts an integer to a float.\nint(x) converts a float to an integer (rounds down).\nround(a, n) rounds the floating point number a to n digits.\ntype(x) returns the datatype of the variable x.\n\nFor a full list, see https://docs.python.org/3/library/functions.html.\nRemark R.60 (Functions in the numpy package)\nTo use these functions, start your code with import numpy as np.\n\nnp.exp(x) exponential function\nnp.log(x) natural log\nnp.log2(x) log base 2\nnp.log10(x) log base 10\nnp.sin(x) sine (radians)\nnp.cos(x) cosine (radians)\nnp.tan(x) tangent (radians)\nnp.arcsin(x) arcsine\nnp.arccos(x) arccosine\nnp.arctan(x) arctangent\nnp.absolute(x) absolute value\nnp.deg2rad(x) degrees to radians\nnp.rad2deg(x) radians to degrees\nnp.sum(x) sum of elements\nnp.prod(x) product of elements\nnp.imag(z) imaginary part\nnp.real(z) real part\nnp.angle(z) angle of a complex number (radians)\nnp.conj(z) complex conjugate\n\nSome constants:\n\nnp.pi\nnp.e\n\nMore info: https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.math.html\nExample E.61\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThere are other packages with even more functions, such as math and scipy. In particular, numpy makes the math package mostly obsolete when working with numpy arrays.\nAppendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_all.html#a.5-how-numbers-are-represented-in-python",
    "href": "appendix_all.html#a.5-how-numbers-are-represented-in-python",
    "title": "Appendix A (All)",
    "section": "A.5 How numbers are represented in Python",
    "text": "A.5 How numbers are represented in Python\nWe end this appendix by examining how numbers are represented in Python and some peculiar consequences of this.\nExample E.62\nAt the start of Chapter 3, we considered the infinite series \\[\\sum_{k=0}^{\\infty} \\frac{1}{2^k} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\cdots.\\]\nLet \\(S_n\\) denote the \\(n\\)th partial sum. The point is that \\(2 - S_n = 1/2^n\\), so \\(S_n \\ne 2\\). But if we ask Python to compute, say, \\(S_{100}\\), it returns 2.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.63\nDoes Python really mean that \\(S_{100} = 2\\), or is there something else going on? One way to double check is to ask Python to compute \\(1 / (2 - S_{100})\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nHow integers are represented in Python\nIf we run\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPython stores the integer using a fixed number of bits (modern computers typically use 64 bits for integers).\n\n\n\n\n\n\nNote\n\n\n\nFigures omitted in this web version.\n\n\nExample E.65 (Decimal and binary notation)\nIn decimal: \\[4132 = 4\\cdot10^3 + 1\\cdot10^2 + 3\\cdot10^1 + 2\\cdot10^0.\\]\nIn binary: \\[1101_2 = 1\\cdot2^3 + 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0.\\]\nIf it is not clear whether a number is written in binary or decimal, we can use the notations \\((1101)_2\\) and \\((1101)_{10}\\).\nCounting in binary: \\((0)_2=0\\), \\((1)_2=1\\), \\((10)_2=2\\), \\((11)_2=3\\), \\((100)_2=4\\), \\((101)_2=5\\), \\((110)_2=6\\), \\((111)_2=7\\), \\((1000)_2=8\\), and so on.\nExercise E.66\nCheck that the above list is correct, and continue the list to 20.\nExercise E.68\n\nWhat is the largest integer you can represent as an 8-bit integer?\nModern computers use 64-bit integers, where 1 bit is used for the sign and 63 for the number itself. What is the largest integer you can represent using a 64-bit integer?\n\nRemark R.69 (Two’s complement)\nOur explanation above is correct for positive integers. For negative integers, a strategy called two’s complement is used. For an 8-bit integer, this allows representation of integers from -128 to 127.\n\n\nHow non-integers are represented in Python\nReal numbers that are not integers are stored using the datatype float. Because memory is finite, not all real numbers can be represented exactly.\nRemark R.70 (Sloppy description of 64-bit floating numbers)\nA 64-bit computer sets aside 64 bits to represent a real number of the form \\(\\epsilon \\cdot 10^\\alpha\\), where \\(\\epsilon\\) is (roughly) a 16-digit integer and the exponent \\(\\alpha\\) is roughly between -340 and +292.\nExample E.71\nUsing the sloppy description, the number \\(\\sqrt{2}\\) is stored roughly as \\[1.414213562373095 \\cdot 10^0.\\]\nExercise E.72\nAccording to the sloppy definition:\n\nHow far is it between the floating point representation of \\(\\sqrt{2}\\) and its closest floating point neighbor?\nHow far is it between \\(x=0\\) and the next floating point number?\n\nExercise E.73\nPut a = 325660000, b = 0.000032566 and use Python to compute 100*(a+b), 1000*(a+b), and 10000*(a+b). How are the results stored? Are there any round-off errors?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExercise E.74\nUse the sloppy description of float numbers to do the following:\n\nExplain how large N has to be for the computer to think that \\(1 + 2^{-N} = 1\\).\nHow large does N have to be for the computer to think that \\(2^{-N} = 0\\)?\n\nExample E.75 (Binary notation for non-integers)\nBinary notation for non-integers works like decimal notation. Compare: \\[643.57_{10} = 6\\cdot10^2 + 4\\cdot10^1 + 3\\cdot10^0 + 5\\cdot10^{-1} + 7\\cdot10^{-2}\\] and \\[101.01_2 = 1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 + 0\\cdot2^{-1} + 1\\cdot2^{-2}.\\]\nExercise E.76\nAs a small taste of binary arithmetic, figure out both the decimal and binary representations of:\n\n\\((101.01)_2 \\cdot 2^2\\)\n\\((101.01)_2 \\cdot 2^1\\)\n\\((101.01)_2 \\cdot 2^{-1}\\)\n\nRemark R.77 (Accurate description of 64-bit floating point numbers)\nA 64-bit floating point number is stored in the form \\[(1.\\epsilon)_2 \\cdot 2^\\alpha,\\] where \\(\\epsilon\\) is a string of 52 bits and the exponent \\(\\alpha\\) is an 11-bit integer. The remaining bit is used for the sign.\nWhen the exponent \\(\\alpha\\) is the smallest possible, \\((1.\\epsilon)_2\\) is replaced by \\((0.\\epsilon)_2\\) to offer additional accuracy close to the origin.\n\n\n\n\n\n\nNote\n\n\n\nFigures omitted in this web version.\n\n\nExample E.78\nHow do we store \\(1/10\\) as a floating point number? The binary expansion of \\(1/10\\) is \\[0.00011001100110011\\ldots_2\\] which is repeating. This means it cannot be stored exactly, so we must round.\nExercise E.79\nTranslate the accurate description of 64-bit floating point numbers to decimal notation to obtain the sloppy description above. Take into account the added accuracy close to the origin.\nExercise E.80 (Challenging)\nExplain which fractions can be represented without round-off error as 64-bit floating point numbers.\nRemark R.81 (The effect of round-off errors)\nWhen using Python to compute and visualize data, we must consider whether results are real or caused by round-off error. This is especially important for functions with large or small scales.\nAppendix A: A crash course in Python\nNUMA01: Computational Programming with Python\nMalin Christersson, Robert Klofkorn"
  },
  {
    "objectID": "appendix_all.html#a.6-answers-to-selected-exercises",
    "href": "appendix_all.html#a.6-answers-to-selected-exercises",
    "title": "Appendix A (All)",
    "section": "A.6 Answers to selected exercises",
    "text": "A.6 Answers to selected exercises\nE.4\n\n\naddition\n\n\nsubtraction\n\n\nmultiplication\n\n\npower\n\n\ndivision\n\n\nfloor division (division rounded down)\n\n\nmodulo (remainder)\n\n\nE.8\nCodes (a), (d), and (f) will not run.\nE.9\n\n\n\\(1 + 1/2 + 1/4 + 1/8 + 1/16\\)\n\n\n\\(1/(1 + 1/(1 + 1/(1 + 1/(1 + 1))))\\)\n\n\nE.11\nThe code in (a) will run.\nE.36\nThe code computes the partial sum \\(S_{99999}\\) of the harmonic series. The speed of the computations will depend on your processor.\nE.40\nHere is one solution:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nE.46\n(a) Using a for-loop and break:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n(b) Using a while-loop:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nE.48\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nE.49\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nE.54\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nE.58\nabsolute1 does not work for numpy arrays because the if-statement does not make sense for arrays. For absolute2, the following code works:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nE.63\nPython crashes with a ZeroDivisionError. In other words, Python really believes that \\(S_{100} = 2\\).\nE.66\nThe first 21 numbers in both binary and decimal notation:\n\n\n\nDecimal\nBinary\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n10\n\n\n3\n11\n\n\n4\n100\n\n\n5\n101\n\n\n6\n110\n\n\n7\n111\n\n\n8\n1000\n\n\n9\n1001\n\n\n10\n1010\n\n\n11\n1011\n\n\n12\n1100\n\n\n13\n1101\n\n\n14\n1110\n\n\n15\n1111\n\n\n16\n10000\n\n\n17\n10001\n\n\n18\n10010\n\n\n19\n10011\n\n\n20\n10100\n\n\n\nE.68\n\n\n\\(2^7 - 1 = 127\\)\n\n\n\\(2^{63} - 1\\)\n\n\nE.72\n\n\nRoughly \\(10^{-16}\\)\n\n\nRoughly \\(10^{-340}\\)\n\n\nE.73\nAccording to the sloppy description, \\(a + b\\) is stored as \\(3256600000000325 \\cdot 10^{17}\\). When printing 100*(a+b), 1000*(a+b) and 10000*(a+b), the 17th digit keeps changing due to round-off errors.\nE.74\n\n\n\\(N = 53\\)\n\n\n\\(N = 1075\\)\n\n\nE.76\n\n\n\\((10101)_2 = 21\\)\n\n\n\\((1010.1)_2 = 10.5\\)\n\n\n\\((10.101)_2 = 2.625\\)\n\n\nE.79\nThe exponent \\(\\alpha\\) is between \\(-1024\\) and \\(1023\\) (counting two’s complement). This means that \\(2^\\alpha\\) is between \\(10^{-308}\\) and \\(10^{308}\\), roughly. Taking into account that \\(\\epsilon\\) is between \\(1\\) and \\(10^{16}\\), and that \\((1.\\epsilon)_2\\) is replaced by \\((0.\\epsilon)_2\\) when \\(\\alpha = -1024\\), we obtain the rough description.\nE.80\nExactly the fractions \\(a / 2^n\\), where \\(a\\) is an integer and \\(n\\) is a natural number. These are the numbers with finite binary expansions."
  }
]